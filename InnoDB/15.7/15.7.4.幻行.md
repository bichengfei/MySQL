# 15.7.4 幻行/幻读

当同一个查询在不同当时间产生不同当结果集时，事务中就会出现所谓当幻行问题。例如，一个 select 执行了两次，但第二次返回了第一次没有返回的行，这就是幻行。

假设表 child 上的列 id 上有一个索引，并且你想要读取并锁定表中标识符大于 100 的所有行，以便稍后更行所选行中的某些列：

```sql
select * from child where id > 100 for update;
```

假设表中包含 id 为 90 和 102 的列。查询从 id > 100 的第一条记录开始扫描索引，如果在扫描范围内地索引记录上设置锁，但不锁定记录间的间隙（例如 90 到 102 之间的间隙），则另一个会话可以将新行插入到表中，例如插入 id = 101 的行。如果你在同一事务中执行了相同的 select 操作，你将在结果集中看到一个 id = 101 新行。如果我们把结果集看成一个数据项，那么新的幻行就会违反事务能够运行的的隔离原则：它所读取的数据在事务过程中不会发生变化

为防止出现幻行，InnoDB 使用一种称之为后码锁（next-key 锁）的算法，该算法将行锁和间隙锁结合。InnoDB 执行行级锁定的方式：当它搜索或扫描索引时，它会在它遇到的索引记录上设置共享或排他锁，因此，行级锁是记录锁；此外，索引记录上的后码锁也会影响索引记录之前的间隙，也就是说，后码锁是记录锁加上索引记录前面的间隙上的间隙锁。如果一个会话在索引记录 R 上有共享或排他锁，其它会话不能在 R 索引顺序之前的间隙中插入新的索引记录。

在 InnoDB 扫描索引时，还可以锁定索引中最后一条记录之后的间隙。在前面的例子中，会发生这种情况：为了防止任何 id > 100 的行插入到表中，设置的锁包括 id > 102 的间隙锁。

你可以使用后码锁锁定在你的应用程序中实现唯一性检查：如果你再共享锁下读取数据，并且没有看到你要插入行的重复项，那么你可以安全的插入你的行，并知道在读取期间在你的行的后继者上设置的后码锁可防止任何人为你的行插入重复行。因此，后码锁使你能够“锁定”表中不存在的行（笔者理解：如果查询一个不存在的索引记录 R，InnoDB 会确定 R 在索引中的范围，然后锁定这个范围间隙）。

如 [15.7.1 InnoDB 锁定](./15.7.1.InnoDB锁定.md)，可以禁用间隙锁。这可能会导致幻读问题，因为当间隙锁被禁用时，其它会话可以将新行插入到间隙中。
