# 15.7.5.3 如何最小化和处理死锁

本节基于[15.7.5.2.死锁检测](./15.7.5.2.死锁检测.md)中有关死锁的概念信息，它解释了如何组织数据库操作以最小化死锁和应用程序中所需的后续错误处理

死锁是事务数据库中的一个经典问题，但他们并不危险，除非它们太频繁以至于你根本无法运行某些事务。通常，你必须编写应用程序，以便它们随时准备好在事务因为死锁而回滚时重新发出事务。

你可以使用以下技术应对死锁并降低其发生但可能性：

+ 使用`show engine innodb status`，以确定最近死锁的原因，这可以帮助你调整应用程序以避免死锁。

+ 如果频繁的死锁警告引起关注，请通过启用`innodb_print_all_deadlockes`来收集更广泛的调试信息。MySQL 的错误日志中，包含有关每个死锁的信息，而不仅仅是最新的。完成调试后禁用此选项

+ 如果由于死锁而失败，请始终准备好重新发出事务，死锁并不危险，再试一次。

+ 保持交易小且持续时间短，以减少它们发生冲突的可能性

+ 在进行一组相关更改后立即提交事务，以降低它们发生冲突的可能性。特别是，不要让交互式 mysql 会话在未提交事务的情况下长时间打开。

+ 如果你使用锁定读取（select ... from update 或 select ... for share），请尝试使用较低是隔离级别，例如 read commited

+ 当修改一个事务中的多个表，或不同表中的不同行集时，每次都以一致的顺序执行这些操作，然后事务形成定义明确的队列并且不会死锁。例如，将数据库操作组织成应用程序中的函数，或调用存储例程（call stored routines），而不是在不同位置编写多个相似的 insert、update、delete 语句序列

+ 为你的表添加精心挑选的索引，以便你的查询扫描更少的索引记录并设置更少的锁。使用`explain select`确定 MySQL 服务器使用哪些索引最适合你的查询。

+ 使用较少的锁定。如果你有允许 select 从旧快照中返回数据，请不要在其中 for update 或者 for share 子句。在这里使用 read commited 隔离级别很好，因为同一个事务中的每次一致读取都从其自己的新快照中读取

+ 如果没有其它帮助，请使用表级锁序列化你的事务。将 lock tables 与事务表（例如 InnoDB 表）一起使用的正确方式是使用 `set autocommit = 0`（不是 `start transaction`）开始事务，然后是 lock tables，并且在显示提交事务之前不要调用`unlock tables`。例如，如果你需要写入到表 t1 并且需要读取表 t2，你可以这样做：
  
  ```sql
  SET autocommit=0;
  LOCK TABLES t1 WRITE, t2 READ, ...;
  ... do something with tables t1 and t2 here ...
  COMMIT;
  UNLOCK TABLES;
  ```
  
  表级锁可防止对表的并发更新，避免死锁，但会降低对繁忙系统的响应速度

+ - 序列化事务的另一种方法是创建一个仅包含一行的辅助“信号量”表。让每个事务在访问其他表之前更新该行。这样，所有交易都以串行方式发生。请注意，`InnoDB` 即时死锁检测算法也适用于这种情况，因为序列化锁是行级锁。使用 MySQL 表级锁，必须使用 timeout 方法来解决死锁。
