# 15.7.5 InnoDB 中的死锁

死锁是一种不同事务无法继续进行的情况，因为每个事务都持有另一个需要的锁。因为两个事务都在等待资源变得可用，所以它们都不会释放它持有的锁。

当事务锁定多个表中的行（通过诸如 update、`select ... for update`之类语句），但顺序相反时，可能会发生死锁。当此列语句锁定索引记录和间隙的范围时，也可能发生死锁，每个事务由于时间问题而获得一些锁，但没有获得其它锁。有关死锁示例，请参阅 [15.7.5.1 InnoDB 死锁示例](./15.7.5.1.InnoDB死锁示例.md)

为了减少死锁的可能性：

+ 使用事务而不是`lock tables`语句

+ 保持插入和更新的事务足够小，以使其不会长时间保持打开状态

+ 当不同事务更新多个表或大范围的行时，在每个事务中使用相同的操作顺序（类似`select ... for update`）

+ 在`select ... fro update`和`update ... where`所使用的列上创建索引

死锁的可能性不受隔离级别的影响，因为隔离级别改变了读操作的行为，而死锁时因为写操作而发生的。有关避免死锁条件和从死锁条件中恢复的更多信息，请参阅[15.7.5.3.如何最小化和处理死锁](./15.7.5.3.如何最小化和处理死锁.md)

当启用死锁检测（默认）并且发生死锁时，InnoDB 检测条件并回滚其中一个事务（受害者）。如果通过`innodb_deadlock_detect`参数禁用死锁检测，则在死锁发生时，InnoDB 依赖`innodb_lock_wait_timeout`参数设置回滚事务。因此，即使你的程序逻辑是正确的，你仍然必须处理必须重试事务的情况。要查看用户事务在 InnoDB 中的最后一个死锁，请使用`show engine innodb status`。如果频繁的死锁突出了事务结构或应用程序处理的问题，启用`innodb_print_all_deadlockes`将有关所有死锁的信息打印到 mysqld 错误日志。有关如何自动检测和处理死锁的更多信息，请参阅[15.7.5.2.死锁检测](./15.7.5.2.死锁检测.md)
