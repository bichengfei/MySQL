# 12.10.1 自然语言全文搜索

默认或使用`IN NATURAL LANGUAGE MODE`修饰符的情况下，`MATCH()` 函数针对文本集合执行自然语言搜索。集合是包含在全文索引中的一列或多列的组合；搜索字符串作为`AGAINST（）`函数的参数给出。对于表中的每一行，`MATCH()`返回一个相关值；也就是搜索字符串与`MATCH()`集合中的列中的文本之间的相似性度量值/相关性。

```sql
mysql> CREATE TABLE articles (
          id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,
          title VARCHAR(200),
          body TEXT,
          FULLTEXT (title,body)
        ) ENGINE=InnoDB;
Query OK, 0 rows affected (0.08 sec)

mysql> INSERT INTO articles (title,body) VALUES
        ('MySQL Tutorial','DBMS stands for DataBase ...'),
        ('How To Use MySQL Well','After you went through a ...'),
        ('Optimizing MySQL','In this tutorial, we show ...'),
        ('1001 MySQL Tricks','1. Never run mysqld as root. 2. ...'),
        ('MySQL vs. YourSQL','In the following database comparison ...'),
        ('MySQL Security','When configured properly, MySQL ...');
Query OK, 6 rows affected (0.01 sec)
Records: 6  Duplicates: 0  Warnings: 0

mysql> SELECT * FROM articles
        WHERE MATCH (title,body)
        AGAINST ('database' IN NATURAL LANGUAGE MODE);
+----+-------------------+------------------------------------------+
| id | title             | body                                     |
+----+-------------------+------------------------------------------+
|  1 | MySQL Tutorial    | DBMS stands for DataBase ...             |
|  5 | MySQL vs. YourSQL | In the following database comparison ... |
+----+-------------------+------------------------------------------+
2 rows in set (0.00 sec)
```

默认情况下，搜索以不区分大小写的方式执行。要执行区分大小写的全文搜索，请对索引列使用区分大小写或二进制排序规则。例如，可以为使用 utf8mb4 字符集的列分配 utf8mb4_0900_as_cs 或 utf8mb4_bin 的排序规则，以使其在全文搜索时区分大小写。

当在 where 子句中使用 match() 时，如前面所示，只要满足以下条件，返回的行将自动以最高相关性有序排序：

+ 不能有明确的 order by 子句

+ 必须使用全文索引扫描而不是表扫描来执行搜索

+ 如果有连接查询，全文索引扫描必须是连接中最左边的非常量表。

鉴于刚刚列出的条件，当需要或期望使用 order by 明确的排序顺序时，通常只能获得更少的成就。

相关性值是非负浮点数。零相关性意味着没有相似性。相关性是根据行（文档）中的单词数、行中唯一单词的数量、集合中的单词总数以及包含特定单词的行数来计算的。

```textile
笔记
  术语“文档”可以与术语“行”互换使用，这两个术语都指行的索引部分
  术语“集合”指的是索引列并包含所有行
```

要简单地计算匹配项，你可以使用如下查询：

```sql
mysql> SELECT COUNT(*) FROM articles
    WHERE MATCH (title,body)
    AGAINST ('database' IN NATURAL LANGUAGE MODE);
+----------+
| COUNT(*) |
+----------+
|        2 |
+----------+
1 row in set (0.00 sec)
```

你可能会发现按如下方式重写查询会更快：

```sql
mysql> SELECT
    COUNT(IF(MATCH (title,body) AGAINST ('database' IN NATURAL LANGUAGE MODE), 1, NULL))
    AS count
    FROM articles;
+-------+
| count |
+-------+
|     2 |
+-------+
1 row in set (0.03 sec)
```

第一个查询做了一些额外的工作（按相关性对结果进行排序），但也可以使用基于 where 子句对索引查找。如果搜索匹配几行，则索引查找可能会使第一个查询更快。第二个查询执行全表扫描，如果搜索词出现在大多数行中，这可能比索引查找更快。

对于自然语言搜索，MATCH() 中命名的列必须与表中全文索引中包含的列相同。对于前面查询，请注意 MATCH() 函数中命名的列（title 和 body）与 articles 表中的全文索引中命名的列相同。要单独搜索 title 或 body，你需要为每列创建单独的全文索引。

你可以执行布尔搜索或带有查询扩展的搜索，后两篇文章中有描述。

使用全文索引的全文搜索的 MATCH() 函数中，只能命名单个表中的列，因为索引不能跨越多个表。对于 MyISAM 表，可以在没有索引的情况下进行布尔搜索（速度较慢），在这种情况下，可以从多个表中命名列。

前面的示例是一个基本说明，展示了如何使用 MATCH() 函数，其中行按相关性递减的顺序返回。下一个示例显示如何显示检索相关值。返回的行没有排序，因为 select 语句既不包含  where 也不包含 order by 子句：

```sql
mysql> SELECT id, MATCH (title,body)
    AGAINST ('Tutorial' IN NATURAL LANGUAGE MODE) AS score
    FROM articles;
+----+---------------------+
| id | score               |
+----+---------------------+
|  1 | 0.22764469683170319 |
|  2 |                   0 |
|  3 | 0.22764469683170319 |
|  4 |                   0 |
|  5 |                   0 |
|  6 |                   0 |
+----+---------------------+
6 rows in set (0.00 sec)
```

下面的查询更复杂。该查询返回相关性值，并且还按相关性递减的顺序对行进行排序。要实现此结果，请指定 MATCH() 两次：一次在 select 列表中，一次在 where 子句中。这不会导致额外的开销，因为 MySQL 优化器注意到这两个 MATCH() 调用是相同的，并且只调用一次全文搜索代码。

```sql
mysql> SELECT id, body, MATCH (title,body) AGAINST
    ('Security implications of running MySQL as root'
    IN NATURAL LANGUAGE MODE) AS score
    FROM articles WHERE MATCH (title,body) AGAINST
    ('Security implications of running MySQL as root'
    IN NATURAL LANGUAGE MODE);
+----+-------------------------------------+-----------------+
| id | body                                | score           |
+----+-------------------------------------+-----------------+
|  4 | 1. Never run mysqld as root. 2. ... | 1.5219271183014 |
|  6 | When configured properly, MySQL ... | 1.3114095926285 |
+----+-------------------------------------+-----------------+
2 rows in set (0.00 sec)
```

包含在双引号（"）字符中的短语仅匹配按字面意思包含该短语的行，因为它是键入的。全文引擎将短语拆分为单词，并在 FULLTEXT 中搜索这些单词。非单词字符不需要完全匹配：短语搜索只需要匹配包含与短语完全相同的单词并且顺序相同，例如，"test phrase"匹配"test,phrase"。如果索引中不包含短语中的单词，则结果为空，例如，如果所有单词都是停用词或短于索引词的最小长度，则结果为空。

MySQL FULLTEXT 实现将任何真正的字符（字母、数字、下划线）序列视为一个单词，该序列也可能包含撇号（’），但连续不超过一个。这意味着`aaa'bbb`被视为一个单词，但`aaa''bbb`被视为两个单词。FULLTEXT 解析器会去除单词开头或结尾的撇号；`'aaa'bbb'`将被解析为`aaa'bbb`。

内置的 FULLTEXT 解析器通过查找某些分隔符来确定单词的开始和结束位置，例如：空格、逗号和段落。如果单词没有用分隔符分割，例如在中文中，则内置的 FULLTEXT 解析器无法确定单词的开始或结束位置。
